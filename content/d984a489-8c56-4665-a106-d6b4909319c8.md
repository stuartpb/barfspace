# printacle

this is my project to make an OctoPrint killer

## Subpages etc

- [best practice / pipeline for versioning printed models](b65a21d3-ed3d-41ac-aa22-122d551404ce.md)
- [cancelobject for printacle](b6be21f9-fcd2-4f2f-8953-a49b71f17bf9.md)

## the key difference between printacle and octoprint

OctoPrint primarily models itself like a serial controller for the printer's axes

printacle primarily sees itself as a content processor that manages a cache of instructions on a FlashAir

printacle can span multiple machines, with the dev side of the pipeline living on a developer desktop and the gcode-dispatching and flash-drive monitoring on the RPi

printacle is more fundamentally modular, using MODULE_TREE as a base (where you can use `node_modules` as that MODULE_TREE? what about name collisions since installed Node modules might have spec-matching-looking structure)

maybe there's a PLUMBUS_PREFIX where Plumbus-related dirs should be searched for in subtrees? that just sounds like a way to make nightmare incompatible MT modules (or ecosystems)?

more likely we just have NPMed modules symlinked in if they've got some kind of Plumbus component

anyway yeah I was thinking you could have a module-tree module that starts a skeleton Node process like Envigor that constructs an Express server by passing a shared app object through all the middleware constructors defined as their modules' entrypoint

that'd include a module adding the in-process API (ie. adding methods to the app object) for contacting the JSON-to-terminal server, and all the other "basic OctoPrint-like functionality" bits

the module that adds a router for handling `GET /` (ie. the dashboard) adds the functions to register "dashboard plugins"

## implementation notes

see [WebSocket-to-Serial Implementations](d0d9c829-a69a-49ea-a9cb-eedcb34cab21.md) for thoughts on how to structure that whole shebang

gotta look up the stuff about how Chrome OS does image swapping - that could maybe be generalized out to a tool for "define your module_tree loadout as an image" (though, really, doesn't this eventually just become Docker images and volumes?)

anyway, even the simplest partition swapper would be better than OctoPi's "back up your settings then re-flash the microsd"

## snippet implementation

My thinking is that any sequence of commands to be sent to the printer are batched into a file, which is then canonicalized, hashed, and uploaded to a "commands" object-store folder, and dispatched from the SD card

I'm guessing "print file from SD" commands can be dispatched from an SD file, but work like a GOTO? Still, that's a thing I was thinking, that this could be used for one-way flow control (if all snippets are stored by hash)

Hmm, you could also create named aliases (usable as variables to make mutable flow control, even) by uploading files in a different namespace (like refs) where the only command in the file is a command that dispatches the gcode file by content

hmm... maybe each project has its own namespace, like separate git repos. and the project can carry along stuff like the common start gcode just a bunch of times redundantly, like how it works now

mm, but I'm thinking now about the firmware's 100 file limit (and how the redundant routines are nbd in this paradigm because they don't use up file nodes)...

also, a thing I'm thinking about is how you could do some real neato flow control by having each step have its "trailer" as a named file mirroring itself - since sequence control has to be one-way and sequential (like, with no stack), this would allow for, say, a number of large snippets, to be joined sequentially by just "manipulating their next-node pointers", so to speak

isn't this kind of overkill, though, since you could just rewrite the last line of the file? I don't know if this strict "always be uploading whole files" model is necessary

this also feels kind of like a possible Plushu design paradigm overlap?
