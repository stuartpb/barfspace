# current thoughts on printacle

I'm thinking it can be like OctoPrint/OctoPi, where there's "printacle" and "piprintacle" or "pintacle" or "printberry" or something

the form factor for printacle, in this formulation, would be akin to kubelet: makin it work requires a fair amount of scaffolding , which is left as an excercise for the distro

and so, like, if, say, Prusa wants to make a derivative image, they can come up with their own extension mechanism

anyway, point is, this would be specially designed for the Pi (as OctoPrint is, in practice), and implementations for other systems would have to be wrapped up in some other out-of-scope formulation that isn't part of the "core project"

## how the pi image would work

Based on Raspbian, just because, you know, path of least resistance

OverlayFS for creating a Module Tree based on the system-provided image and local customizations, so the "base image" can be updated easily

further "enhancement layers" (read: vendor extensions) could be implemented as overlay layers? that might be an interesting way of "setting up the system", kind of like Docker images

in fact, could this actually use the Docker image format?

so I'm thinking the OverlayFS might just straight up be on `/etc`?

## the frontend design

that whole Tabalanche model kind of feels like it'd fit Printacle?

but, yeah, anyway, you'd have the base server be, like, a Go process

the frontend views are all rendered via a Plumbus hook + filter for each view in the app - one hook handles headers and stuff, and another handles rendering the page

the "views" in question are very broad, though, like "app" and "settings" - most interface stuff beyond that is handled

in fact, as I think about it, damn, you could implement this with, like, *netcat*

I'm definitely thinking Plumbus hooks/etc should be namespaced like Kubernetes, but in directories with reversed-domain names, so all the shared-domain groups lexically group together (like I might have `org.example.foo` and `org.example.bar` as two separate-but-related hook namespaces)

one open question API-wise: what about WebSockets? Is there any kind of equivalent construct in plumbus? Do we just execute a hook/filter on every incoming message (but, you know, the hook/filter that corresponds to that message)

see, the idea I'm thinking this could support is `org.printacle.websocket`, `org.printacle.view`, `org.printacle.post`, things like that - where you could let the hook names be an extensible app-level construct. so like, you know, `org.printacle.view/index` is the path for injecting HTML into the index

so that kind of makes them like a "class" level?

also, I don't think the namespace for these would be "printacle": this is starting to sound like an interesting server model, and I might want to come up with a higher-level abstraction for it

Also, there'd need to be some kind of "static files" tree for modules to serve their frontend assets from

## oh yeah, also

There's the aspect of, like, having chilipepr or whatever handling the serial connection. So I'd have to figure out how I'd want that to mount: do we put all this under an Nginx tying it all together, the Module-Tree-to-HTTP server and the Chilipepr WebSocket?

I feel like, yeah, you kind of do need to do that? Also, having an Nginx config might let us have that "serve static files from this subdirectory of all these projects"

This'd be another thing the Raspberry Pi distro would be able to tailor to the environment that you'd have to figure out in a repackaging: how to lay out this "network". Like, do we create an iptables rule that's like a `NodePort` service, or a `ClusterIP`? Do we make entries for the underlying services in `/etc/hosts`?

Oh man, actually, should even the names like "hooks" in a module be namespaced, so they're "org.plumbus.hooks"? so, like, we could then have "org.plumbus.hooks/xxx.schleem.view", alongside "xxx.schleem.static"

Or, like, screw it, maybe we just ditch the `hooks` level? or invert it, so under `xxx.schleem.views` you'd have "hooks" and "filters" as directories

I think what'd make the most sense would be to combine them, so it's like `xxx.schleem.resource.cat` and `xxx.schleem.resource.filter`, and the structure underneath that is paths for the class of resource that is generated by concatenating static files (read: frontend plugin lists)

I'm wondering if it might not make sense to have a thing where the paths can be arbitrarily deep, but the last level is suffixed with `.d`?

also, oh man, if you were gonna concat a D programming language resource, it'd be `whatever.d.d`

and, like, would this even truly need a Go thing? Might it even be possible to configure with Nginx's Lua stuff?
